<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title></title>
</head>
<body>
<pre class="w_doc">
<h1 class="h1">希尔排序算法</h1>
是一种难以理解的算法。

代码：
<xmp class="block">
  public void ShellSort()
  {
    int inner, temp;
    int h = 3;
    while(h > 0)
    {
      for(int outer = h; outer <= numElements - 1; outer++)
      {
        temp = arr[outer];
        inner = outer;
        while((inner > h - 1) && arr[inner - h] >= temp)
        {
          arr[inner] = arr[inner -h];
          inner -= h;
        }
        arr[inner] = temp;
      }
      h = (h - 1) % 3;
    }
  }
</xmp>

<h1 class="h1">归并排序算法</h1>
原理：把集合分成两个部分，然后对每个部分递归地进行排序。
     当两个部分都排序耗时，在合并程序把它们组合在一起。

代码：
<xmp class="block">
  public void MergeSort()
  {
    int[] tempArray = new int[numElements];
    RecmergeSort(tempArray, 0, numElements - 1);
  }
  public void ReeMergeSort(int[] tempArrat, int lbound, int ubound)
  {
    if(lbound == ubound)
    {
      return;
    }
    else
    {
      int mid = (int)(lbound + ubound) / 2;
      RecMergeSort(tempArray, lbound, mid);
      RecMergeSort(tempArray, mid + 1, ubound);
      Merge(tempArray, lbound, mid + 1,ubound);
    }
  }
  public void Merge(int[] tempArray, int lowp, int highp, int ubound)
  {
    int lbound = lowp;
    int mid = highp -1;
    int n = (ubound - lbound) + 1;
    int j = 0;
    while((lowp <= mid) && (highp <= ubound))
    {
      if(arrp[lowp] < arrp[highp])
      {
        tempArray[j] = arr[lowp];
        j++;
        lowp++;
      }
      else
      {
        tempArray[j] = arr[highp]        };
        j++;
        highp++;
      }
    }
    while(lowp <= mid)
    {
      tempArray[j] = arr[lowp];
      j++;
      lowp++;
    }
    while(highp <= ubound)
    {
      tempArray[j] = arr[highp];
      j++;
      highp++;
    }
    for(j = 0; j <= n -1; j++)
    {
      arr[lbound + j] = tempArray[j];
    }
  }
</xmp>

<h1 class="h1">快速排序算法</h1>
对于大量数据而言，快速排序算法应该是速度最快的算法。

代码：
<xmp class="block">
  public void QSort()
  {
    RecQSort(0,numElement - 1);
  }
  public void RecQSort(int first, int last)
  {
    if((last - first) <= 0)
    {
      return;
    }
    else
    {
      int parat = this.Partition(first,last);
      RecQSort(first,part - 1);
      RecQSort(part + 1,last);
    }
  }
  public int Partition(int first,int last)
  {
    int pivotVal = arr[first];
    int theFirst = first;
    bool okSide;
    first++;
    do
    {
      okSide = true;
      while(okSide)
      {
        if(arr[first] > pivotVal)
        {
          okSide = false;
        }
        else
        {
          first++;
          okSide = (first <= last);
        }
      }

      while(okSide)
      {
        if(arr[last] <= pivotVal)
        {
          okSide = false;
        }
        else
        {
          last--;
          okSide = (first <= last);
        }
      }

      if(first < last)
      {
        Swap(first,last);
        this.DisplayElements();
        first++;
        last--;
      }
    }while(first <= last);
    Swap(thisFirst,last);
    this.DisplayElements();
    return last;
  }

  public void Swap(int item1, int item2)
  {
    int temp  = arr[item1];
    arr[item1] = arr[item2];
    arr[item2] = temp;
  }
</xmp>
</pre>
</body>
</html>
