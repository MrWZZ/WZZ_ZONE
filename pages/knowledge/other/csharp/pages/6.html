<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title></title>
</head>
<body>
<pre class="w_doc">
<h1 class="h1">装箱与拆箱</h1>
装箱：显示地将值类型分配给System.Object变量的过程。
     当我们对一个值进行装箱的时候，CLR就会在堆上分配新的对象并且将值类型的值复制到那个实例上，因此
     返回的是新分配堆上的对象的引用。
拆箱：把保存在对象引用中的值转换回栈上的相应值类型。

使用集合等的类型的时候会引起装箱、拆箱导致的性能问题。所以我们将使用泛型，来提高性能和安全性。

<h1 class="h1">泛型</h1>
只有类、结构、接口、方法和委托可以使用泛型，枚举类型不可以。

<b>创建泛型方法</b>
<xmp class="block">
  public void Swap<T>(ref T a,ref T b)
  {
    T temp = a;
    a = b;
    b = temp;
  }
</xmp>
泛型方法会根据里面的参数自行推断类型，但至少要有一个参数。
我们还可以用泛型来创建结构和类。

<b>default</b>
在泛型中，default被重载，用来给泛型赋默认值。
<xmp class="block">
  public void Reset()
  {
    X = default(T);
    Y = default(T);
  }
</xmp>

<h1 class="h1">约束</h1>
使用where可以给类型参数添加一组约束。
+ where : struct          该类型参数T必须是值类型
+ where : class           该类型参数T必须是引用类型
+ where : new()           该类型参数T必须拥有默认构造函数，多个约束时，该约束放到末尾
+ where : BaseClass       该类型参数T必须派生于BaseClass
+ where : Interface       该类型参数T必须实现Interface，多接口用逗号隔开

<xmp class="block">
  public class Car<T,K>
  where T : class,new()
  where K : struct
  {
    //...
  }
</xmp>
在泛型方法中，使用计算操作符等会出错（+ ，- ，* ，==）。

</pre>
</body>
</html>
