<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
    <link rel="stylesheet" href="/WZZ_ZONE/pages/summary.css">
  </head>
  <body>
<pre class="w_doc">
<h1 class="h1">链表</h1>
  链表是被称为节点的类对象的群集。
  每一个节点通过一个引用链接到列表内的后继节点上。
  节点包括储存数据的字段节点引用的字段。

  链表的设计至少包含两个类。
  + Node类：储存数据的类。
  + LinkedList类：对链表进行操作的类。

<h2 class="h2">Node类</h2>
  节点是由两个数据成员组成的，储存着节点数据的Element，以及储存着指向表内下一个节点的引用Link。

  代码：
  <xmp class="block">
    public class Node
    {
      public Object Element;
      public Node Link;
      public Node()
      {
        Element = null;
        Link = null;
      }

      public Node(Object theElement)
      {
        Element = theElement;
        Link = null;
      }
    }
  </xmp>

<h2 class="h2">LinkedList类</h2>
  这个类包含几种方法，有把节点添加到链表的方法，有从链表中移除节点的方法，有遍历链表的方法。。。
  下面是一个简单的单向链表。

  代码：
  <xmp class="block">
    public class Linkedlist
    {
      protected Node header;
      public LinkedList()
      {
        header = new Node("header");
      }

      private Node Find(Object item)
      {
        Node current = new Node();
        current = header;
        While(current.Element != item)
        {
          current = current.Link;
        }
        return current;
      }

      //添加
      public void Insert(Object newItem, Object after)
      {
        Node current =  new Node();
        Node newNode = Node(newItem);
        current = Find(after);
        newNode.Link = current.Link;
        current.Link = newNode;
      }

      //移除方法前置
      private Node FindPrevious(Object n)
      {
        Node current = header;
        while(!(current.Link == null) && (current.Link.Element != n))
        {
          current = current.Link;
        }
        return current;
      }

      //移除
      public void Remove(Object n)
      {
        Node p = FindPrevious(n);
        if(!(p.Link == null))
        {
          P.Link = p.Link.link;
        }
      }

      //打印链表
      public void Printlist()
      {
        Node current = new node();
        current = header;
        while(!(current.Link == null))
        {
          Console.WriteLink(current.Link.Element);
          current = current.Link;
        }
      }
    }
  </xmp>

  双向链表的设计思路可根据单向链表进行扩展。
  JS语言的双向链表实例可在Github主页U3D仓库中GameLink章节查看。
</pre>
  </body>
</html>
